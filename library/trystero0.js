
/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/trystero@0.22.0/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{schnorr as e}from"./trystero1.js";
const{floor:t,random:r,sin:n}=Math,a="Trystero",o=(e,t)=>Array(e).fill().map(t),s="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",c=e=>o(e,(()=>s[t(62*r())])).join(""),i=c(20),l=Promise.all.bind(Promise),d="undefined"!=typeof window,{entries:y,fromEntries:u,keys:m}=Object,f=()=>{},p=e=>new Error(`${a}: ${e}`),w=new TextEncoder,g=new TextDecoder,h=e=>w.encode(e),b=e=>g.decode(e),k=e=>e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),v=(...e)=>e.join("@"),P=(e,r,a,o)=>(e.relayUrls||(o?((e,r)=>{const a=[...e],o=()=>{const e=1e4*n(r++);return e-t(e)};let s=a.length;for(;s;){const e=t(o()*s--);[a[s],a[e]]=[a[e],a[s]]}return a})(r,S(e.appId)):r)).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||a),T=JSON.stringify,A=JSON.parse,S=(e,t=Number.MAX_SAFE_INTEGER)=>e.split("").reduce(((e,t)=>e+t.charCodeAt(0)),0)%t,E={};let L=null,D=null;const C=()=>{L||(L=new Promise((e=>{D=e})).finally((()=>{D=null,L=null})))},I=()=>D?.(),$="AES-GCM",U={},O=async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,h(t))),R=async e=>U[e]||=Array.from(await O("SHA-1",e)).map((e=>e.toString(36))).join(""),j=async(e,t)=>{const r=crypto.getRandomValues(new Uint8Array(16));return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:$,iv:r},await e,h(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},x=async(e,t)=>{const[r,n]=t.split("$");return b(await crypto.subtle.decrypt({name:$,iv:new Uint8Array(r.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map(((e,r)=>t.charCodeAt(r))).buffer})(n)))},H="icegatheringstatechange",M="offer";var J=(e,{rtcConfig:t,rtcPolyfill:r,turnConfig:n})=>{const a=new(r||RTCPeerConnection)({iceServers:N.concat(n||[]),...t}),o={};let s=!1,c=!1,i=null;const d=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>o.data?.(e.data),e.onopen=()=>o.connect?.(),e.onclose=()=>o.close?.(),e.onerror=e=>o.error?.(e)},y=e=>Promise.race([new Promise((t=>{const r=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(H,r),t())};e.addEventListener(H,r),r()})),new Promise((e=>setTimeout(e,5e3)))]).then((()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")})));return e?(i=a.createDataChannel("data"),d(i)):a.ondatachannel=({channel:e})=>{i=e,d(e)},a.onnegotiationneeded=async()=>{try{s=!0,await a.setLocalDescription();const e=await y(a);o.signal?.(e)}catch(e){o.error?.(e)}finally{s=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&o.close?.()},a.ontrack=e=>{o.track?.(e.track,e.streams[0]),o.stream?.(e.streams[0])},a.onremovestream=e=>o.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return i},get isDead(){return"closed"===a.connectionState},async signal(t){if("open"!==i?.readyState||t.sdp?.includes("a=rtpmap"))try{if(t.type===M){if(s||"stable"!==a.signalingState&&!c){if(e)return;await l([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(t)])}else await a.setRemoteDescription(t);await a.setLocalDescription();const r=await y(a);return o.signal?.(r),r}if("answer"===t.type){c=!0;try{await a.setRemoteDescription(t)}finally{c=!1}}}catch(e){o.error?.(e)}},sendData:e=>i.send(e),destroy:()=>{i?.close(),a.close(),s=!1,c=!1},setHandlers:e=>Object.assign(o,e),offerPromise:e?new Promise((e=>o.signal=t=>{t.type===M&&e(t)})):Promise.resolve(),addStream:e=>e.getTracks().forEach((t=>a.addTrack(t,e))),removeStream:e=>a.getSenders().filter((t=>e.getTracks().includes(t.track))).forEach((e=>a.removeTrack(e))),addTrack:(e,t)=>a.addTrack(e,t),removeTrack:e=>{const t=a.getSenders().find((t=>t.track===e));t&&a.removeTrack(t)},replaceTrack:(e,t)=>{const r=a.getSenders().find((t=>t.track===e));if(r)return r.replaceTrack(t)}}};const N=[...o(3,((e,t)=>`stun:stun${t||""}.l.google.com:19302`)),"stun:stun.cloudflare.com:3478"].map((e=>({urls:e}))),K=Object.getPrototypeOf(Uint8Array),_=16369,q=255,B="bufferedamountlow",G=e=>"@_"+e;var V=(e,t,r)=>{const n={},s={},c={},i={},w={},g={},k={},v={onPeerJoin:f,onPeerLeave:f,onPeerStream:f,onPeerTrack:f},P=(e,t)=>(e?Array.isArray(e)?e:[e]:m(n)).flatMap((e=>{const r=n[e];return r?t(e,r):(console.warn(`${a}: no peer with id ${e} found`),[])})),S=e=>{n[e]&&(n[e].destroy(),delete n[e],delete i[e],delete w[e],v.onPeerLeave(e),t(e))},E=e=>{if(s[e])return c[e];if(!e)throw p("action type argument is required");const t=h(e);if(t.byteLength>12)throw p(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(t);let a=0;return s[e]={onComplete:f,onProgress:f,setOnComplete:t=>s[e]={...s[e],onComplete:t},setOnProgress:t=>s[e]={...s[e],onProgress:t},send:async(e,t,s,c)=>{if(s&&"object"!=typeof s)throw p("action meta argument must be an object");const i=typeof e;if("undefined"===i)throw p("action data cannot be undefined");const d="string"!==i,y=e instanceof Blob,u=y||e instanceof ArrayBuffer||e instanceof K;if(s&&!u)throw p("action meta argument can only be used with binary data");const m=u?new Uint8Array(y?await e.arrayBuffer():e):h(d?T(e):e),f=s?h(T(s)):null,w=Math.ceil(m.byteLength/_)+(s?1:0)||1,g=o(w,((e,t)=>{const n=t===w-1,o=s&&0===t,c=new Uint8Array(15+(o?f.byteLength:n?m.byteLength-_*(w-(s?2:1)):_));return c.set(r),c.set([a],12),c.set([n|o<<1|u<<2|d<<3],13),c.set([Math.round((t+1)/w*q)],14),c.set(s?o?f:m.subarray((t-1)*_,t*_):m.subarray(t*_,(t+1)*_),15),c}));return a=a+1&q,l(P(t,(async(e,t)=>{const{channel:r}=t;let a=0;for(;a<w;){const o=g[a];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((e=>{const t=()=>{r.removeEventListener(B,t),e()};r.addEventListener(B,t)})),!n[e])break;t.sendData(o),a++,c?.(o[14]/q,e,s)}})))}},c[e]||=[s[e].send,s[e].setOnComplete,s[e].setOnProgress]},L=async()=>{await M(""),await new Promise((e=>setTimeout(e,99))),y(n).forEach((([e,t])=>{t.destroy(),delete n[e]})),r()},[D,C]=E(G("ping")),[I,$]=E(G("pong")),[U,O]=E(G("signal")),[R,j]=E(G("stream")),[x,H]=E(G("track")),[M,J]=E(G("leave"));return e(((e,t)=>{n[t]||(n[t]=e,e.setHandlers({data:e=>((e,t)=>{const r=new Uint8Array(t),n=b(r.subarray(0,12)).replaceAll("\0",""),[o]=r.subarray(12,13),[c]=r.subarray(13,14),[l]=r.subarray(14,15),d=r.subarray(15),y=!!(1&c),u=!!(2&c),m=!!(4&c),f=!!(8&c);if(!s[n])return void console.warn(`${a}: received message with unregistered type (${n})`);i[e]||={},i[e][n]||={};const p=i[e][n][o]||={chunks:[]};if(u?p.meta=A(b(d)):p.chunks.push(d),s[n].onProgress(l/q,e,p.meta),!y)return;const w=new Uint8Array(p.chunks.reduce(((e,t)=>e+t.byteLength),0));if(p.chunks.reduce(((e,t)=>(w.set(t,e),e+t.byteLength)),0),delete i[e][n][o],m)s[n].onComplete(w,e,p.meta);else{const t=b(w);s[n].onComplete(f?A(t):t,e)}})(t,e),stream:e=>{v.onPeerStream(e,t,g[t]),delete g[t]},track:(e,r)=>{v.onPeerTrack(e,r,t,k[t]),delete k[t]},signal:e=>U(e,t),close:()=>S(t),error:e=>{console.error(e),S(t)}}),v.onPeerJoin(t))})),C(((e,t)=>I("",t))),$(((e,t)=>{w[t]?.(),delete w[t]})),O(((e,t)=>n[t]?.signal(e))),j(((e,t)=>g[t]=e)),H(((e,t)=>k[t]=e)),J(((e,t)=>S(t))),d&&addEventListener("beforeunload",L),{makeAction:E,leave:L,ping:async e=>{if(!e)throw p("ping() must be called with target peer ID");const t=Date.now();return D("",e),await new Promise((t=>w[e]=t)),Date.now()-t},getPeers:()=>u(y(n).map((([e,t])=>[e,t.connection]))),addStream:(e,t,r)=>P(t,(async(t,n)=>{r&&await R(r,t),n.addStream(e)})),removeStream:(e,t)=>P(t,((t,r)=>r.removeStream(e))),addTrack:(e,t,r,n)=>P(r,(async(r,a)=>{n&&await x(n,r),a.addTrack(e,t)})),removeTrack:(e,t)=>P(t,((t,r)=>r.removeTrack(e))),replaceTrack:(e,t,r,n)=>P(r,(async(r,a)=>{n&&await x(n,r),a.replaceTrack(e,t)})),onPeerJoin:e=>v.onPeerJoin=e,onPeerLeave:e=>v.onPeerLeave=e,onPeerStream:e=>v.onPeerStream=e,onPeerTrack:e=>v.onPeerTrack=e}};const z={},F="EVENT",{secretKey:Q,publicKey:W}=e.keygen(),X=k(W),Y={},Z={},ee={},te=()=>Math.floor(Date.now()/1e3),re=e=>ee[e]??=S(e,1e4)+2e4,ne=async(t,r)=>{const n={kind:re(t),tags:[["x",t]],created_at:te(),content:r,pubkey:X},a=await O("SHA-256",T([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]));return T([F,{...n,id:k(a),sig:k(await e.signAsync(a,Q))}])},ae=(e,t)=>(Y[e]=t,T(["REQ",e,{kinds:[re(t)],since:te(),"#x":[t]}])),oe=e=>(delete Y[e],T(["CLOSE",e])),se=(({init:e,subscribe:t,announce:r})=>{const n={};let s,c,y,u,m=!1;return(w,g,b)=>{const{appId:k}=w;if(n[k]?.[g])return n[k][g];const P={},S={},E=v(a,k,g),L=R(E),D=R(v(E,i)),U=(async(e,t,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},h(`${e}:${t}:${r}`)),{name:$},!1,["encrypt","decrypt"]))(w.password||"",k,g),O=e=>async t=>({type:t.type,sdp:await e(U,t.sdp)}),H=O(x),M=O(j),N=()=>J(!0,w),K=(e,t,r)=>{S[t]?S[t]!==e&&e.destroy():(S[t]=e,W(e,t),P[t]?.forEach(((e,t)=>{t!==r&&e.destroy()})),delete P[t])},_=(e,t)=>{S[t]===e&&delete S[t]},q=e=>(c.push(...o(e,N)),l(c.splice(0,e).map((e=>e.offerPromise.then(M).then((t=>({peer:e,offer:t}))))))),B=(e,t)=>b?.({error:`incorrect password (${w.password}) when decrypting ${t}`,appId:k,peerId:e,roomId:g}),G=e=>async(t,r,n)=>{const[a,o]=await l([L,D]);if(t!==a&&t!==o)return;const{peerId:s,offer:c,answer:d,peer:y}="string"==typeof r?A(r):r;if(s!==i&&!S[s])if(!s||c||d){if(c){const t=P[s]?.[e];if(t&&i>s)return;const r=J(!1,w);let a;r.setHandlers({connect:()=>K(r,s,e),close:()=>_(r,s)});try{a=await H(c)}catch{return void B(s,"offer")}if(r.isDead)return;const[o,d]=await l([R(v(E,s)),r.signal(a)]);n(o,T({peerId:i,answer:await M(d)}))}else if(d){let t;try{t=await H(d)}catch(e){return void B(s,"answer")}if(y)y.setHandlers({connect:()=>K(y,s,e),close:()=>_(y,s)}),y.signal(t);else{const r=P[s]?.[e];r&&!r.isDead&&r.signal(t)}}}else{if(P[s]?.[e])return;const[[{peer:t,offer:r}],a]=await l([q(1),R(v(E,s))]);P[s]||=[],P[s][e]=t,setTimeout((()=>((e,t)=>{if(S[e])return;const r=P[e]?.[t];r&&(delete P[e][t],r.destroy())})(s,e)),.9*z[e]),t.setHandlers({connect:()=>K(t,s,e),close:()=>_(t,s)}),n(a,T({peerId:i,offer:r}))}};if(!w)throw p("requires a config map as the first argument");if(!k&&!w.firebaseApp)throw p("config map is missing appId field");if(!g)throw p("roomId argument required");if(!m){const t=e(w);c=o(20,N),s=Array.isArray(t)?t:[t],m=!0,y=setInterval((()=>c=c.filter((e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}))),59052.99),u=w.manualRelayReconnection?f:(()=>{if(d){const e=new AbortController;return addEventListener("online",I,{signal:e.signal}),addEventListener("offline",C,{signal:e.signal}),()=>e.abort()}return f})()}const z=s.map((()=>5333)),F=[],Q=s.map((async(e,r)=>t(await e,await L,await D,G(r),q)));l([L,D]).then((([e,t])=>{const n=async(a,o)=>{const s=await r(a,e,t);"number"==typeof s&&(z[o]=s),F[o]=setTimeout((()=>n(a,o)),z[o])};Q.forEach((async(e,t)=>{await e,n(await s[t],t)}))}));let W=f;return n[k]||={},n[k][g]=V((e=>W=e),(e=>delete S[e]),(()=>{delete n[k][g],F.forEach(clearTimeout),Q.forEach((async e=>(await e)())),clearInterval(y),u(),m=!1}))}})({init:e=>P(e,le,5,!0).map((e=>{const t=((e,t)=>{const r={},n=()=>{const a=new WebSocket(e);a.onclose=()=>{L?L.then(n):(E[e]??=3333,setTimeout(n,E[e]),E[e]*=2)},a.onmessage=e=>t(e.data),r.socket=a,r.url=a.url,r.ready=new Promise((t=>a.onopen=()=>{t(r),E[e]=3333})),r.send=e=>{1===a.readyState&&a.send(e)}};return n(),r})(e,(e=>{const[r,n,o,s]=A(e);if(r===F)Z[n]?.(Y[n],o.content);else{const e=`${a}: relay failure from ${t.url} - `;"NOTICE"===r?console.warn(e+n):"OK"!==r||o||console.warn(e+s)}}));return z[e]=t,t.ready})),subscribe:(e,t,r,n)=>{const a=c(64),o=c(64);return Z[a]=Z[o]=(t,r)=>n(t,r,(async(t,r)=>e.send(await ne(t,r)))),e.send(ae(a,t)),e.send(ae(o,r)),()=>{e.send(oe(a)),e.send(oe(o)),delete Z[a],delete Z[o]}},announce:async(e,t)=>e.send(await ne(t,T({peerId:i})))}),ce=(ie=z,()=>u(y(ie).map((([e,t])=>[e,t.socket]))));var ie;const le=["black.nostrcity.club","ftp.halifax.rwth-aachen.de/nostr","nos.lol","nostr.cool110.xyz","nostr.data.haus","nostr.sathoarder.com","nostr.vulpem.com","relay.agorist.space","relay.binaryrobot.com","relay.damus.io","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.verified-nostr.com","yabu.me/v2"].map((e=>"wss://"+e));export{ce as getRelaySockets,se as joinRoom,C as pauseRelayReconnection,I as resumeRelayReconnection,i as selfId};export default null;
//# sourceMappingURL=/sm/da6e6e10800336aeb455f621dba01a480129b1376c5a7a4562cf454972f37564.map

