
/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/secp256k1@3.0.0/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const t={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:e,n:n,Gx:r,Gy:s,b:a}=t,o=32,i=64,f={publicKey:33,publicKeyUncompressed:65,signature:i,seed:48},c=(t="")=>{const e=new Error(t);throw((...t)=>{"captureStackTrace"in Error&&"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(...t)})(e,c),e},u=(t,e,n="")=>{const r=(s=t)instanceof Uint8Array||ArrayBuffer.isView(s)&&"Uint8Array"===s.constructor.name;var s;const a=t?.length,o=void 0!==e;if(!r||o&&a!==e){c((n&&`"${n}" `)+"expected Uint8Array"+(o?` of length ${e}`:"")+", got "+(r?`length=${a}`:"type="+typeof t))}return t},l=t=>new Uint8Array(t),y=(t,e)=>t.toString(16).padStart(e,"0"),d=t=>Array.from(u(t)).map((t=>y(t,2))).join(""),h=48,p=57,m=65,b=70,g=97,x=102,w=t=>t>=h&&t<=p?t-h:t>=m&&t<=b?t-(m-10):t>=g&&t<=x?t-(g-10):void 0,v=t=>{const e="hex invalid";if("string"!=typeof t)return c(e);const n=t.length,r=n/2;if(n%2)return c(e);const s=l(r);for(let n=0,a=0;n<r;n++,a+=2){const r=w(t.charCodeAt(a)),o=w(t.charCodeAt(a+1));if(void 0===r||void 0===o)return c(e);s[n]=16*r+o}return s},A=()=>globalThis?.crypto,B=()=>A()?.subtle??c("crypto.subtle must be defined, consider polyfill"),S=(...t)=>{const e=l(t.reduce(((t,e)=>t+u(e).length),0));let n=0;return t.forEach((t=>{e.set(t,n),n+=t.length})),e},E=(t=o)=>A().getRandomValues(l(t)),K=BigInt,U=(t,e,n,r="bad number: out of range")=>(t=>"bigint"==typeof t)(t)&&e<=t&&t<n?t:c(r),k=(t,n=e)=>{const r=t%n;return r>=0n?r:n+r},V=t=>k(t,n),Z=(t,e)=>{(0n===t||e<=0n)&&c("no inverse n="+t+" mod="+e);let n=k(t,e),r=e,s=0n,a=1n;for(;0n!==n;){const t=r%n,e=s-a*(r/n);r=n,n=t,s=a,a=e}return 1n===r?k(s,e):c("no inverse")},T=t=>{const e=ut[t];return"function"!=typeof e&&c("hashes."+t+" not set"),e},X=t=>T("sha256")(t),Y=t=>t instanceof G?t:c("Point expected"),H=t=>k(k(t*t)*t+a),j=t=>U(t,0n,e),q=t=>U(t,1n,e),C=t=>U(t,1n,n),O=t=>0n===(1n&t),P=t=>Uint8Array.of(t),R=t=>P(O(t)?2:3),$=t=>{const n=H(q(t));let r=1n;for(let t=n,s=(e+1n)/4n;s>0n;s>>=1n)1n&s&&(r=r*t%e),t=t*t%e;return k(r*r)===n?r:c("sqrt invalid")};class G{static BASE;static ZERO;X;Y;Z;constructor(t,e,n){this.X=j(t),this.Y=q(e),this.Z=j(n),Object.freeze(this)}static CURVE(){return t}static fromAffine(t){const{x:e,y:n}=t;return 0n===e&&0n===n?M:new G(e,n,1n)}static fromBytes(t){u(t);const{publicKey:e,publicKeyUncompressed:n}=f;let r;const s=t.length,a=t[0],l=t.subarray(1),y=D(l,0,o);if(s===e&&(2===a||3===a)){let t=$(y);const e=O(t);O(K(a))!==e&&(t=k(-t)),r=new G(y,t,1n)}return s===n&&4===a&&(r=new G(y,D(l,o,i),1n)),r?r.assertValidity():c("bad point: not on curve")}static fromHex(t){return G.fromBytes(v(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){const{X:e,Y:n,Z:r}=this,{X:s,Y:a,Z:o}=Y(t),i=k(e*o),f=k(s*r),c=k(n*o),u=k(a*r);return i===f&&c===u}is0(){return this.equals(M)}negate(){return new G(this.X,k(-this.Y),this.Z)}double(){return this.add(this)}add(t){const{X:e,Y:n,Z:r}=this,{X:s,Y:o,Z:i}=Y(t);let f=0n,c=0n,u=0n;const l=k(3n*a);let y=k(e*s),d=k(n*o),h=k(r*i),p=k(e+n),m=k(s+o);p=k(p*m),m=k(y+d),p=k(p-m),m=k(e+r);let b=k(s+i);return m=k(m*b),b=k(y+h),m=k(m-b),b=k(n+r),f=k(o+i),b=k(b*f),f=k(d+h),b=k(b-f),u=k(0n*m),f=k(l*h),u=k(f+u),f=k(d-u),u=k(d+u),c=k(f*u),d=k(y+y),d=k(d+y),h=k(0n*h),m=k(l*m),d=k(d+h),h=k(y-h),h=k(0n*h),m=k(m+h),y=k(d*m),c=k(c+y),y=k(b*m),f=k(p*f),f=k(f-y),y=k(p*d),u=k(b*u),u=k(u+y),new G(f,c,u)}subtract(t){return this.add(Y(t).negate())}multiply(t,e=!0){if(!e&&0n===t)return M;if(C(t),1n===t)return this;if(this.equals(z))return ne(t).p;let n=M,r=z;for(let s=this;t>0n;s=s.double(),t>>=1n)1n&t?n=n.add(s):e&&(r=r.add(s));return n}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){const{X:t,Y:n,Z:r}=this;if(this.equals(M))return{x:0n,y:0n};if(1n===r)return{x:t,y:n};const s=Z(r,e);return 1n!==k(r*s)&&c("inverse invalid"),{x:k(t*s),y:k(n*s)}}assertValidity(){const{x:t,y:e}=this.toAffine();return q(t),q(e),k(e*e)===H(t)?this:c("bad point: not on curve")}toBytes(t=!0){const{x:e,y:n}=this.assertValidity().toAffine(),r=J(e);return t?S(R(n),r):S(P(4),r,J(n))}toHex(t){return d(this.toBytes(t))}}const z=new G(r,s,1n),M=new G(0n,1n,0n);G.BASE=z,G.ZERO=M;const N=(t,e,n)=>z.multiply(e,!1).add(t.multiply(n,!1)).assertValidity(),I=t=>K("0x"+(d(t)||"0")),D=(t,e,n)=>I(t.subarray(e,n)),F=2n**256n,J=t=>v(y(U(t,0n,F),i)),L=t=>{const e=I(u(t,o,"secret key"));return U(e,1n,n,"invalid secret key: outside of range")},Q=t=>t>n>>1n,W=(t,e=!0)=>z.multiply(L(t)).toBytes(e),_=t=>{[0,1,2,3].includes(t)||c("recovery id must be valid and present")},tt=(t,e=st)=>{(t=>{null==t||it.includes(t)||c(`Signature format must be one of: ${it.join(", ")}`),t===ot&&c('Signature format "der" is not supported: switch to noble-curves')})(e);const n=f.signature,r=n+1;let s=`Signature format "${e}" expects Uint8Array with length `;e===st&&t.length!==n&&c(s+n),e===at&&t.length!==r&&c(s+r)};class et{r;s;recovery;constructor(t,e,n){this.r=C(t),this.s=C(e),null!=n&&(this.recovery=n),Object.freeze(this)}static fromBytes(t,e=st){let n;tt(t,e),e===at&&(n=t[0],t=t.subarray(1));const r=D(t,0,o),s=D(t,o,i);return new et(r,s,n)}addRecoveryBit(t){return new et(this.r,this.s,t)}hasHighS(){return Q(this.s)}toBytes(t=st){const{r:e,s:n,recovery:r}=this,s=S(J(e),J(n));return t===at?(_(r),S(Uint8Array.of(r),s)):s}}const nt=t=>{const e=8*t.length-256;e>1024&&c("msg invalid");const n=I(t);return e>0?n>>K(e):n},rt=t=>V(nt(u(t))),st="compact",at="recovered",ot="der",it=[st,at,ot],ft={lowS:!0,prehash:!0,format:st,extraEntropy:!1},ct="SHA-256",ut={hmacSha256Async:async(t,e)=>{const n=B(),r="HMAC",s=await n.importKey("raw",t,{name:r,hash:{name:ct}},!1,["sign"]);return l(await n.sign(r,s,e))},hmacSha256:void 0,sha256Async:async t=>l(await B().digest(ct,t)),sha256:void 0},lt=(t,e,n)=>(u(t,void 0,"message"),e.prehash?n?ut.sha256Async(t):T("sha256")(t):t),yt=l(0),dt=P(0),ht=P(1),pt="drbg: tried max amount of iterations",mt=(t,e)=>{let n=l(o),r=l(o),s=0;const a=()=>{n.fill(1),r.fill(0)},i=(...t)=>T("hmacSha256")(r,S(n,...t)),f=(t=yt)=>{r=i(dt,t),n=i(),0!==t.length&&(r=i(ht,t),n=i())};let u;for(a(),f(t);!(u=e((s++>=1e3&&c(pt),n=i(),n)));)f();return a(),u},bt=async(t,e)=>{let n=l(o),r=l(o),s=0;const a=()=>{n.fill(1),r.fill(0)},i=(...t)=>ut.hmacSha256Async(r,S(n,...t)),f=async(t=yt)=>{r=await i(dt,t),n=await i(),0!==t.length&&(r=await i(ht,t),n=await i())},u=async()=>(s++>=1e3&&c(pt),n=await i(),n);let y;for(a(),await f(t);!(y=e(await u()));)await f();return a(),y},gt=(t,e,r,s)=>{let{lowS:a,extraEntropy:i}=r;const f=J,c=rt(t),l=f(c),y=L(e),d=[f(y),l];if(null!=i&&!1!==i){const t=!0===i?E(o):i;d.push(u(t,void 0,"extraEntropy"))}const h=S(...d),p=c;return s(h,(t=>{const e=nt(t);if(!(1n<=e&&e<n))return;const s=Z(e,n),o=z.multiply(e).toAffine(),i=V(o.x);if(0n===i)return;const f=V(s*V(p+i*y));if(0n===f)return;let c=(o.x===i?0:2)|Number(1n&o.y),u=f;a&&Q(f)&&(u=V(-f),c^=1);return new et(i,u,c).toBytes(r.format)}))},xt=(t,e,r,s={})=>{const{lowS:a,format:o}=s;t instanceof et&&c("Signature must be in Uint8Array, use .toBytes()"),tt(t,o),u(r,void 0,"publicKey");try{const{r:s,s:i}=et.fromBytes(t,o),f=rt(e),c=G.fromBytes(r);if(a&&Q(i))return!1;const u=Z(i,n),l=V(f*u),y=V(s*u),d=N(c,l,y).toAffine();return V(d.x)===s}catch(t){return!1}},wt=t=>{const e={};return Object.keys(ft).forEach((n=>{e[n]=t[n]??ft[n]})),e},vt=(t,e,n={})=>(n=wt(n),t=lt(t,n,!1),gt(t,e,n,mt)),At=async(t,e,n={})=>(n=wt(n),t=await lt(t,n,!0),gt(t,e,n,bt)),Bt=(t,e,n,r={})=>(r=wt(r),e=lt(e,r,!1),xt(t,e,n,r)),St=async(t,e,n,r={})=>(r=wt(r),e=await lt(e,r,!0),xt(t,e,n,r)),Et=(t,e)=>{const r=et.fromBytes(t,"recovered"),{r:s,s:a,recovery:i}=r;_(i);const f=rt(u(e,o)),c=2===i||3===i?s+n:s;q(c);const l=R(K(i)),y=S(l,J(c)),d=G.fromBytes(y),h=Z(c,n),p=V(-f*h),m=V(a*h);return N(d,p,m).toBytes()},Kt=(t,e,n={})=>(e=lt(e,wt(n),!1),Et(t,e)),Ut=async(t,e,n={})=>(e=await lt(e,wt(n),!0),Et(t,e)),kt=(t,e,n=!0)=>G.fromBytes(e).multiply(L(t)).toBytes(n),Vt=(t=E(f.seed))=>{u(t),(t.length<f.seed||t.length>1024)&&c("expected 40-1024b");const e=k(I(t),n-1n);return J(e+1n)},Zt=t=>e=>{const n=Vt(e);return{secretKey:n,publicKey:t(n)}},Tt=Zt(W),Xt={hexToBytes:v,bytesToHex:d,concatBytes:S,bytesToNumberBE:I,numberToBytesBE:J,mod:k,invert:Z,randomBytes:E,secretKeyToScalar:L,abytes:u},Yt={isValidSecretKey:t=>{try{return!!L(t)}catch(t){return!1}},isValidPublicKey:(t,e)=>{const{publicKey:n,publicKeyUncompressed:r}=f;try{const s=t.length;return(!0!==e||s===n)&&((!1!==e||s===r)&&!!G.fromBytes(t))}catch(t){return!1}},randomSecretKey:Vt},Ht=t=>Uint8Array.from("BIP0340/"+t,(t=>t.charCodeAt(0))),jt="nonce",qt="challenge",Ct=(t,...e)=>{const n=T("sha256"),r=n(Ht(t));return n(S(r,r,...e))},Ot=async(t,...e)=>{const n=ut.sha256Async,r=await n(Ht(t));return await n(S(r,r,...e))},Pt=t=>{const e=L(t),n=z.multiply(e),{x:r,y:s}=n.assertValidity().toAffine();return{d:O(s)?e:V(-e),px:J(r)}},Rt=t=>V(I(t)),$t=(...t)=>Rt(Ct(qt,...t)),Gt=async(...t)=>Rt(await Ot(qt,...t)),zt=t=>Pt(t).px,Mt=Zt(zt),Nt=(t,e,n)=>{const{px:r,d:s}=Pt(e);return{m:u(t),px:r,d:s,a:u(n,o)}},It=t=>{const e=Rt(t);0n===e&&c("sign failed: k is zero");const{px:n,d:r}=Pt(J(e));return{rx:n,k:r}},Dt=(t,e,n,r)=>S(e,J(V(t+n*r))),Ft="invalid signature produced",Jt=(t,r,s,a)=>{const f=u(t,i,"signature"),c=u(r,void 0,"message"),l=u(s,o,"publicKey");try{const t=I(l),r=$(t),s=O(r)?r:k(-r),u=new G(t,s,1n).assertValidity(),h=J(u.toAffine().x),p=D(f,0,o);U(p,1n,e);const m=D(f,o,i);U(m,1n,n);const b=S(J(p),h,c);return y=a(b),d=t=>{const{x:e,y:n}=N(u,m,V(-t)).toAffine();return!(!O(n)||e!==p)},y instanceof Promise?y.then(d):d(y)}catch(t){return!1}var y,d},Lt=(t,e,n)=>Jt(t,e,n,$t),Qt=async(t,e,n)=>Jt(t,e,n,Gt),Wt={keygen:Mt,getPublicKey:zt,sign:(t,e,n=E(o))=>{const{m:r,px:s,d:a,a:i}=Nt(t,e,n),f=Ct("aux",i),u=J(a^I(f)),l=Ct(jt,u,s,r),{rx:y,k:d}=It(l),h=$t(y,s,r),p=Dt(d,y,h,a);return Lt(p,r,s)||c(Ft),p},verify:Lt,signAsync:async(t,e,n=E(o))=>{const{m:r,px:s,d:a,a:i}=Nt(t,e,n),f=await Ot("aux",i),u=J(a^I(f)),l=await Ot(jt,u,s,r),{rx:y,k:d}=It(l),h=await Gt(y,s,r),p=Dt(d,y,h,a);return await Qt(p,r,s)||c(Ft),p},verifyAsync:Qt},_t=Math.ceil(32)+1;let te;const ee=(t,e)=>{const n=e.negate();return t?n:e},ne=t=>{const e=te||(te=(()=>{const t=[];let e=z,n=e;for(let r=0;r<_t;r++){n=e,t.push(n);for(let r=1;r<128;r++)n=n.add(e),t.push(n);e=n.double()}return t})());let n=M,r=z;const s=K(255),a=K(8);for(let o=0;o<_t;o++){let i=Number(t&s);t>>=a,i>128&&(i-=256,t+=1n);const f=128*o,c=f,u=f+Math.abs(i)-1,l=o%2!=0,y=i<0;0===i?r=r.add(ee(l,e[c])):n=n.add(ee(y,e[u]))}return 0n!==t&&c("invalid wnaf"),{p:n,f:r}};export{G as Point,et as Signature,Xt as etc,W as getPublicKey,kt as getSharedSecret,X as hash,ut as hashes,Tt as keygen,Kt as recoverPublicKey,Ut as recoverPublicKeyAsync,Wt as schnorr,vt as sign,At as signAsync,Yt as utils,Bt as verify,St as verifyAsync};export default null;
//# sourceMappingURL=/sm/b4a65ac10c9b22ed7e1edb48a701df9df6c2c7e06e7a456ce2ed4fed5ab754be.map















